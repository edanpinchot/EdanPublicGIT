# -*- coding: utf-8 -*-
"""IrisClassifierPython.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QZTs_IoI7K5ZPQ604FEUvI0EySmh7bPC
"""

from sklearn import datasets
iris = datasets.load_iris()

features = iris.data
irisType = iris.target

petalLength = [row[2] for row in features]
petalWidth = [row[3] for row in features]

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline

df = pd.DataFrame(dict(petalLength=petalLength, petalWidth=petalWidth, irisType=irisType))

fig, ax = plt.subplots()
colors = {0:'red', 1:'purple', 2:'blue'}
ax.scatter(df['petalLength'], df['petalWidth'], c=df['irisType'].apply(lambda x: colors[x]))
plt.title("Petal Length vs. Petal Width")
plt.show

def get_loss(y, a):
  return -1 * (y * np.log(a) +
               (1-y) * np.log(1-a))

def get_loss_numerically_stable(y, z):
   return -1 * (y * -1 * np.log(1 + np.exp(-z)) +
                (1-y) * (-z - np.log(1 + np.exp(-z))))

w_cache = []
b_cache = []
l_cache = []

LEARNING_RATE = 0.001
NUM_EPOCHS = 100

import numpy as np
# some nice initial value, so that the plot looks nice.
w = np.array([-4.0, 29.0])
b = 0.0

sigmoid = lambda x: 1/(1+np.exp(-x))

for i in range(NUM_EPOCHS):
  dw = np.zeros(w.shape)
  db = 0.0
  loss = 0.0
  
  for j in range(features.shape[0]):
    x_j = [features[j][2], features[j][3]]
    y_j = irisType[j]

    z_j = w.dot(x_j) + b
    a_j = sigmoid(z_j)

    loss_j = get_loss_numerically_stable(y_j, z_j)

    dw_j = x_j[0] * x_j[1] * (a_j - y_j)
    db_j = a_j - y_j

    dw += dw_j
    db += db_j
    loss += loss_j

  dw = (1.0/(features.shape[0])) * dw
  db = (1.0/(features.shape[0])) * db
  loss = (1.0/(features.shape[0])) * loss

  w -= LEARNING_RATE * dw
  b -= LEARNING_RATE * db

  #print("w: ", w, " b: ", b, " loss: ", loss)

  w_cache.append(w.copy())
  b_cache.append(b)
  l_cache.append(loss)

plt.grid()
plt.title('Loss', size=18)
plt.xlabel('Number of iterations', size=15)
plt.ylabel('Loss', size=15)
plt.plot(l_cache)

plt.savefig('image.png')

"""Make a Prediction:"""

W = w_cache.pop()               # last w from w_cache
B = b_cache.pop()               # last b from b_cache
X = np.array([5.0, -12.0])      # random point we want to classify

print(sigmoid(W.dot(X) + B))